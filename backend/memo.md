# ディレクトリ構造と役割

API リクエストを受け取ると、以下のように処理が流れる。

> api.gen.go の関数 > handler の関数 > repository の関数 > gorm の中の処理（SQL クエリの実行）

つまり、まず api.gen.go で関数が呼び出され、その中で handler の関数を呼び出し、さらにその中で repository の関数を呼び出す。

### api.gen.go

openapi.yaml から自動生成された Go ファイル。ここにはリクエストの情報を全て含んだ ctx のみを引数にとる関数が書かれている。それぞれの関数は ctx の中からリクエストのパラメータを取り出し、別個の引数として handler の関数に渡して使いやすくする役割を果たす。

openapi.yaml は前後を除けばほとんど paths と components の 2 つの部分の記述である。

- paths ... エンドポイント（アクセスされた場所）と HTTP メソッド（GET, POST, etc...）の組に対してパラメータとレスポンスの形式を定義

- components ... API へのリクエストと応答に用いる型を定義する。内側でさらに parameters と responses と schemas の 3 つに分かれていて、それぞれ「パラメータとして呼ばれる場合があるものの定義」「200 ok 以外の応答の定義」「バックエンドで用いられる型の定義」を書く。型の定義はリレーショナルデータベースにおける型定義方式に基づく

  > 「1 vs 多」の構造である場合「1」に相当するテーブルのレコードの ID を 「多」に相当するテーブルのレコードに置いておく。「1」に相当するテーブルのレコード自体には何も書かない

### handler の関数

api.gen.go の関数の処理によって使いやすくなった引数のパラメータをもとに、操作に合わせて repository の関数を呼び出す。

### repository の関数

それぞれの具体的なデータベース操作に対応する。gorm の恩恵により、抽象化された（SQL 文を書くことなく Go 上の関数の実行によって完結できる）処理を書くことができる。

### model における型定義

リレーショナルデータベースの方式ではなく、フロントエンド側でそのまま使えるような入れ子式の型定義をする。リレーショナルデータベースとの間での読み書きは db.Preload でめちゃくちゃ簡潔に記述することができる。

---

ゆる仕様書からの引用

### 実装のてびき

- openapi.yamlに必要な情報を書く（レスポンスの内容、パラメータなど）
    - operationIdを基に生成される関数の名前が決まる
    - openapi.yamlを編集したらコード生成も忘れずに（docs/generate.md参照）

- DBにどういう情報を保存するか、modelディレクトリ内のファイルに定義する
    - モデルを追加したらmodel/model.goの`GetAllModels()`に追加する（gormが自動でテーブルを作ったりするのに使うため）

- DB操作のロジックはrepositoryディレクトリ内に書いていく

- APIの挙動はhandlerディレクトリ内に実装する
    - handler/api.gen.goの`ServerInterface`に実装すべき関数の型情報だけあるので、別ファイルに同じ名前の関数を実装する
    - データベースの操作はrepositoryを介して行う（handler内で直接触らない）
