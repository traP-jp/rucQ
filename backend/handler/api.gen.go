// Package handler provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package handler

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// Defines values for PostQuestionRequestType.
const (
	PostQuestionRequestTypeFreeNumber PostQuestionRequestType = "free_number"
	PostQuestionRequestTypeFreeText   PostQuestionRequestType = "free_text"
	PostQuestionRequestTypeMultiple   PostQuestionRequestType = "multiple"
	PostQuestionRequestTypeSingle     PostQuestionRequestType = "single"
)

// Defines values for QuestionType.
const (
	QuestionTypeFreeNumber QuestionType = "free_number"
	QuestionTypeFreeText   QuestionType = "free_text"
	QuestionTypeMultiple   QuestionType = "multiple"
	QuestionTypeSingle     QuestionType = "single"
)

// Answer defines model for Answer.
type Answer struct {
	Content    *Answer_Content `json:"content"`
	Id         int             `json:"id"`
	QuestionId int             `json:"question_id"`
	UserTraqId string          `json:"user_traq_id"`
}

// AnswerContent0 defines model for .
type AnswerContent0 = string

// AnswerContent1 defines model for .
type AnswerContent1 = []string

// Answer_Content defines model for Answer.Content.
type Answer_Content struct {
	union json.RawMessage
}

// json.RawMessage は JSON のパースを段階的に行うために使われるとても便利な型
// json.RawMessage 型に指定した部分の JSON 文字列は、パースすることなくとっておける
// たとえば以下のような Response 型があるとして、
// 
// type Response struct {
//     Type string `json:"type"`
//     Data json.RawMessage `json:"data"`
// }
// 
// ある JSON 文字列を json.Unmarshal() によりパースして Response 型の変数 res に格納したとすると、
// res.Data にはその部分に対応する未解析の状態の JSON 文字列が入っている
// パース済みの res.Type の値に応じて res.Data のパース方法を変えたりすることができるようになっている

// そもそも union という属性は Answer_Content と PutAnswerRequest_Content にしか使われていない
// というか、頭文字が小文字なのでこの定義はファイルを出ない。ここでの一時的な処理のためだけに用意されている
// 名前から推測するに、union という属性の存在自体が「ユニオン型」であることの定義なのだろうと思われる
// 

// Budget defines model for Budget.
type Budget struct {
	Amount     *int `json:"amount"`
	AmountPaid int  `json:"amount_paid"`
	CampId     int  `json:"camp_id"`
	Id         int  `json:"id"`
}

// Camp defines model for Camp.
type Camp struct {
	Description string `json:"description"`
	DisplayId   string `json:"display_id"`
	Id          int    `json:"id"`
	IsDraft     bool   `json:"is_draft"`
	Name        string `json:"name"`
}

// Event defines model for Event.
type Event struct {
	ByStaff         bool      `json:"by_staff"`
	CampId          int       `json:"camp_id"`
	Description     string    `json:"description"`
	DisplayColor    string    `json:"display_color"`
	Id              int       `json:"id"`
	Location        string    `json:"location"`
	Name            string    `json:"name"`
	OrganizerTraqId string    `json:"organizer_traq_id"`
	TimeEnd         time.Time `json:"time_end"`
	TimeStart       time.Time `json:"time_start"`
}

// Option defines model for Option.
type Option struct {
	Content    string `json:"content"`
	Id         int    `json:"id"`
	QuestionId int    `json:"question_id"`
}

// PostBudgetRequest defines model for PostBudgetRequest.
type PostBudgetRequest struct {
	Amount     *int `json:"amount"`
	AmountPaid int  `json:"amount_paid"`
	CampId     int  `json:"camp_id"`
}

// PostCampRequest defines model for PostCampRequest.
type PostCampRequest struct {
	Description string `json:"description"`
	DisplayId   string `json:"display_id"`
	IsDraft     bool   `json:"is_draft"`
	Name        string `json:"name"`
}

// PostDMRequest defines model for PostDMRequest.
type PostDMRequest struct {
	Content    string     `json:"content"`
	Sendtime   *time.Time `json:"sendtime,omitempty"`
	TargetUser string     `json:"target_user"`
}

// PostEventRequest defines model for PostEventRequest.
type PostEventRequest struct {
	CampId        int       `json:"camp_id"`
	CreateAsStaff bool      `json:"create_as_staff"`
	Description   string    `json:"description"`
	DisplayColor  string    `json:"display_color"`
	Location      string    `json:"location"`
	Name          string    `json:"name"`
	TimeEnd       time.Time `json:"time_end"`
	TimeStart     time.Time `json:"time_start"`
}

// PostOptionRequest defines model for PostOptionRequest.
type PostOptionRequest struct {
	Content    string `json:"content"`
	QuestionId int    `json:"question_id"`
}

// PostQuestionGroupRequest defines model for PostQuestionGroupRequest.
type PostQuestionGroupRequest struct {
	CampId      int       `json:"camp_id"`
	Description *string   `json:"description"`
	Due         time.Time `json:"due"`
	Name        string    `json:"name"`
}

// PostQuestionRequest defines model for PostQuestionRequest.
type PostQuestionRequest struct {
	Description     string                  `json:"description"`
	IsOpen          bool                    `json:"is_open"`
	IsPublic        bool                    `json:"is_public"`
	QuestionGroupId int                     `json:"question_group_id"`
	Title           string                  `json:"title"`
	Type            PostQuestionRequestType `json:"type"`
}

// PostQuestionRequestType defines model for PostQuestionRequest.Type.
type PostQuestionRequestType string

// PostStaffRequest defines model for PostStaffRequest.
type PostStaffRequest struct {
	TraqId string `json:"traq_id"`
}

// PutAnswerRequest defines model for PutAnswerRequest.
type PutAnswerRequest struct {
	Content *PutAnswerRequest_Content `json:"content"`
}

// PutAnswerRequestContent0 defines model for .
type PutAnswerRequestContent0 = string

// PutAnswerRequestContent1 defines model for .
type PutAnswerRequestContent1 = []string

// PutAnswerRequest_Content defines model for PutAnswerRequest.Content.
type PutAnswerRequest_Content struct {
	union json.RawMessage
}

// Question defines model for Question.
type Question struct {
	Description     *string      `json:"description"`
	Id              int          `json:"id"`
	IsOpen          bool         `json:"is_open"`
	IsPublic        bool         `json:"is_public"`
	Options         *[]Option    `json:"options"`
	QuestionGroupId int          `json:"question_group_id"`
	Title           string       `json:"title"`
	Type            QuestionType `json:"type"`
}

// QuestionType defines model for Question.Type.
type QuestionType string

// QuestionGroup defines model for QuestionGroup.
type QuestionGroup struct {
	CampId      int        `json:"camp_id"`
	Description *string    `json:"description"`
	Due         time.Time  `json:"due"`
	Id          int        `json:"id"`
	Name        string     `json:"name"`
	Questions   []Question `json:"questions"`
}

// User defines model for User.
type User struct {
	IsStaff bool   `json:"is_staff"`
	TraqId  string `json:"traq_id"`
}

// CampId defines model for CampId.
type CampId = int

// EventId defines model for EventId.
type EventId = int

// OptionId defines model for OptionId.
type OptionId = int

// QuestionId defines model for QuestionId.
type QuestionId = int

// StaffId defines model for StaffId.
type StaffId = string

// TraqId defines model for TraqId.
type TraqId = string

// XForwardedUser defines model for X-Forwarded-User.
type XForwardedUser = string

// BadRequest defines model for BadRequest.
type BadRequest struct {
	Message *string `json:"message,omitempty"`
}

// Conflict defines model for Conflict.
type Conflict struct {
	Message *string `json:"message,omitempty"`
}

// Forbidden defines model for Forbidden.
type Forbidden struct {
	Message *string `json:"message,omitempty"`
}

// InternalServerError defines model for InternalServerError.
type InternalServerError struct {
	Message *string `json:"message,omitempty"`
}

// NotFound defines model for NotFound.
type NotFound struct {
	Message *string `json:"message,omitempty"`
}

// PostCampParams defines parameters for PostCamp.
type PostCampParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PutCampParams defines parameters for PutCamp.
type PutCampParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PostDirectMessageParams defines parameters for PostDirectMessage.
type PostDirectMessageParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PostEventParams defines parameters for PostEvent.
type PostEventParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PutEventParams defines parameters for PutEvent.
type PutEventParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// UnregisterEventParams defines parameters for UnregisterEvent.
type UnregisterEventParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// RegisterEventParams defines parameters for RegisterEvent.
type RegisterEventParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// GetMeParams defines parameters for GetMe.
type GetMeParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// GetMyAnswerParams defines parameters for GetMyAnswer.
type GetMyAnswerParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PutAnswerParams defines parameters for PutAnswer.
type PutAnswerParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// GetMyBudgetParams defines parameters for GetMyBudget.
type GetMyBudgetParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PostOptionParams defines parameters for PostOption.
type PostOptionParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PutOptionParams defines parameters for PutOption.
type PutOptionParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PostQuestionGroupParams defines parameters for PostQuestionGroup.
type PostQuestionGroupParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PostQuestionParams defines parameters for PostQuestion.
type PostQuestionParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// DeleteQuestionParams defines parameters for DeleteQuestion.
type DeleteQuestionParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PutQuestionParams defines parameters for PutQuestion.
type PutQuestionParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// DeleteStaffParams defines parameters for DeleteStaff.
type DeleteStaffParams struct {
	// StaffId 合宿係のtraQ ID
	StaffId StaffId `form:"staff_id" json:"staff_id"`

	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PostStaffParams defines parameters for PostStaff.
type PostStaffParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// GetUserAnswerParams defines parameters for GetUserAnswer.
type GetUserAnswerParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PutUserAnswerParams defines parameters for PutUserAnswer.
type PutUserAnswerParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// GetUserBudgetParams defines parameters for GetUserBudget.
type GetUserBudgetParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PostUserBudgetParams defines parameters for PostUserBudget.
type PostUserBudgetParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PutUserBudgetParams defines parameters for PutUserBudget.
type PutUserBudgetParams struct {
	// XForwardedUser ログインしているユーザーのtraQ ID（NeoShowcaseが自動で付与）
	XForwardedUser *XForwardedUser `json:"X-Forwarded-User,omitempty"`
}

// PostCampJSONRequestBody defines body for PostCamp for application/json ContentType.
type PostCampJSONRequestBody = PostCampRequest

// PutCampJSONRequestBody defines body for PutCamp for application/json ContentType.
type PutCampJSONRequestBody = PostCampRequest

// PostDirectMessageJSONRequestBody defines body for PostDirectMessage for application/json ContentType.
type PostDirectMessageJSONRequestBody = PostDMRequest

// PostEventJSONRequestBody defines body for PostEvent for application/json ContentType.
type PostEventJSONRequestBody = PostEventRequest

// PutEventJSONRequestBody defines body for PutEvent for application/json ContentType.
type PutEventJSONRequestBody = PostEventRequest

// PutAnswerJSONRequestBody defines body for PutAnswer for application/json ContentType.
type PutAnswerJSONRequestBody = PutAnswerRequest

// PostOptionJSONRequestBody defines body for PostOption for application/json ContentType.
type PostOptionJSONRequestBody = PostOptionRequest

// PutOptionJSONRequestBody defines body for PutOption for application/json ContentType.
type PutOptionJSONRequestBody = PostOptionRequest

// PostQuestionGroupJSONRequestBody defines body for PostQuestionGroup for application/json ContentType.
type PostQuestionGroupJSONRequestBody = PostQuestionGroupRequest

// PostQuestionJSONRequestBody defines body for PostQuestion for application/json ContentType.
type PostQuestionJSONRequestBody = PostQuestionRequest

// PutQuestionJSONRequestBody defines body for PutQuestion for application/json ContentType.
type PutQuestionJSONRequestBody = PostQuestionRequest

// PostStaffJSONRequestBody defines body for PostStaff for application/json ContentType.
type PostStaffJSONRequestBody = PostStaffRequest

// PutUserAnswerJSONRequestBody defines body for PutUserAnswer for application/json ContentType.
type PutUserAnswerJSONRequestBody = PutAnswerRequest

// PostUserBudgetJSONRequestBody defines body for PostUserBudget for application/json ContentType.
type PostUserBudgetJSONRequestBody = PostBudgetRequest

// PutUserBudgetJSONRequestBody defines body for PutUserBudget for application/json ContentType.
type PutUserBudgetJSONRequestBody = PostBudgetRequest

// これ以降なぜかめっちゃ AnswerContent 関連の関数が出てくる
// おそらく、openapi.yaml において Answer.Content の型を oneOf にしていることが原因のひとつだと思われる
// openapi.yaml における Answer.Content の型設定をコピペしてくると、以下の通り
//
// content:
// oneOf:
//   - type: string
//   - type: array
// 	   items:
// 	       type: string
// nullable: true
//
// つまり、Answer.Content は「string 配列」「string 型配列」「null」のいずれかを受け付ける
// TypeScript でいえば string | string[] | null というユニオン型で書くべきところ
// 「何通りかの文字列だけが入る型」「何通りかの型のうち一つである型」は TypeScript では両方ともユニオン型で書くことができるが、
// openapi.yaml で書く場合は前者を enum、後者を oneOf と書いて区別するらしい
// 
// oneOf の設定は openapi.yaml では Answer と PutAnswerRequest にしか登場していないので、
// それ関連の特殊な対応のために以下インターフェース型の定義が始まるまで長らく関数宣言に紙幅を費やしているのだと思われる

// AnswerContent0 型 = string 型、AnswerContent1 型 = []string 型 である
// nullable であるところにはあまり触れない？

// AsAnswerContent0 returns the union data inside the Answer_Content as a AnswerContent0
func (t Answer_Content) AsAnswerContent0() (AnswerContent0, error) {
	var body AnswerContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}
// Answer_Content 型の変数 content があるとする。content は属性 union を持つ
// content.AsAnswerContent0() は content.union を AnswerContent0（すなわち string 型）として取り出して返却する関数

// FromAnswerContent0 overwrites any union data inside the Answer_Content as the provided AnswerContent0
func (t *Answer_Content) FromAnswerContent0(v AnswerContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}
// AnswerContent0 型（すなわち string 型）の変数 v を受け取り、
// v を t 自身の union に JSON 文字列として代入する。t は v を表現する Answer_Content 型となる

// こういう関数を answers.go（おそらく手書き…？）でも使っているっぽい
// ぜったい AsString とか FromArrayString とかの言い方にしてくれた方が使いやすいのに…

// MergeAnswerContent0 performs a merge with any union data inside the Answer_Content, using the provided AnswerContent0
func (t *Answer_Content) MergeAnswerContent0(v AnswerContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnswerContent1 returns the union data inside the Answer_Content as a AnswerContent1
func (t Answer_Content) AsAnswerContent1() (AnswerContent1, error) {
	var body AnswerContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnswerContent1 overwrites any union data inside the Answer_Content as the provided AnswerContent1
func (t *Answer_Content) FromAnswerContent1(v AnswerContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnswerContent1 performs a merge with any union data inside the Answer_Content, using the provided AnswerContent1
func (t *Answer_Content) MergeAnswerContent1(v AnswerContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Answer_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Answer_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPutAnswerRequestContent0 returns the union data inside the PutAnswerRequest_Content as a PutAnswerRequestContent0
func (t PutAnswerRequest_Content) AsPutAnswerRequestContent0() (PutAnswerRequestContent0, error) {
	var body PutAnswerRequestContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPutAnswerRequestContent0 overwrites any union data inside the PutAnswerRequest_Content as the provided PutAnswerRequestContent0
func (t *PutAnswerRequest_Content) FromPutAnswerRequestContent0(v PutAnswerRequestContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePutAnswerRequestContent0 performs a merge with any union data inside the PutAnswerRequest_Content, using the provided PutAnswerRequestContent0
func (t *PutAnswerRequest_Content) MergePutAnswerRequestContent0(v PutAnswerRequestContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPutAnswerRequestContent1 returns the union data inside the PutAnswerRequest_Content as a PutAnswerRequestContent1
func (t PutAnswerRequest_Content) AsPutAnswerRequestContent1() (PutAnswerRequestContent1, error) {
	var body PutAnswerRequestContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPutAnswerRequestContent1 overwrites any union data inside the PutAnswerRequest_Content as the provided PutAnswerRequestContent1
func (t *PutAnswerRequest_Content) FromPutAnswerRequestContent1(v PutAnswerRequestContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePutAnswerRequestContent1 performs a merge with any union data inside the PutAnswerRequest_Content, using the provided PutAnswerRequestContent1
func (t *PutAnswerRequest_Content) MergePutAnswerRequestContent1(v PutAnswerRequestContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PutAnswerRequest_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PutAnswerRequest_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 合宿の一覧を取得
	// (GET /api/camps)
	GetCamps(ctx echo.Context) error
	// 合宿を作成
	// (POST /api/camps)
	PostCamp(ctx echo.Context, params PostCampParams) error
	// デフォルトの合宿を取得
	// (GET /api/camps/default)
	GetDefaultCamp(ctx echo.Context) error
	// 合宿の詳細を取得
	// (GET /api/camps/{camp_id})
	GetCamp(ctx echo.Context, campId CampId) error
	// 合宿を更新
	// (PUT /api/camps/{camp_id})
	PutCamp(ctx echo.Context, campId CampId, params PutCampParams) error
	// DMを送信
	// (POST /api/dm)
	PostDirectMessage(ctx echo.Context, params PostDirectMessageParams) error
	// イベントの一覧を取得
	// (GET /api/events)
	GetEvents(ctx echo.Context) error
	// イベントを作成
	// (POST /api/events)
	PostEvent(ctx echo.Context, params PostEventParams) error
	// イベントの詳細を取得
	// (GET /api/events/{event_id})
	GetEvent(ctx echo.Context, eventId EventId) error
	// イベントを更新
	// (PUT /api/events/{event_id})
	PutEvent(ctx echo.Context, eventId EventId, params PutEventParams) error
	// イベントの参加者一覧を取得
	// (GET /api/events/{event_id}/participants)
	GetParticipants(ctx echo.Context, eventId EventId) error
	// イベントへの参加をキャンセル
	// (DELETE /api/events/{event_id}/register)
	UnregisterEvent(ctx echo.Context, eventId EventId, params UnregisterEventParams) error
	// イベントに参加
	// (POST /api/events/{event_id}/register)
	RegisterEvent(ctx echo.Context, eventId EventId, params RegisterEventParams) error
	// 自分の情報を取得
	// (GET /api/me)
	GetMe(ctx echo.Context, params GetMeParams) error
	// 自分の回答を取得
	// (GET /api/me/answers/{question_id})
	GetMyAnswer(ctx echo.Context, questionId QuestionId, params GetMyAnswerParams) error
	// 回答を更新
	// (PUT /api/me/answers/{question_id})
	PutAnswer(ctx echo.Context, questionId QuestionId, params PutAnswerParams) error
	// 自分の予算を取得
	// (GET /api/me/budgets)
	GetMyBudget(ctx echo.Context, params GetMyBudgetParams) error
	// 選択肢を作成
	// (POST /api/options)
	PostOption(ctx echo.Context, params PostOptionParams) error
	// 選択肢を更新
	// (PUT /api/options/{option_id})
	PutOption(ctx echo.Context, optionId OptionId, params PutOptionParams) error
	// 質問グループの一覧を取得
	// (GET /api/question_groups)
	GetQuestionGroups(ctx echo.Context) error
	// 質問グループを作成
	// (POST /api/question_groups)
	PostQuestionGroup(ctx echo.Context, params PostQuestionGroupParams) error
	// 質問の一覧を取得
	// (GET /api/questions)
	GetQuestions(ctx echo.Context) error
	// 質問を作成
	// (POST /api/questions)
	PostQuestion(ctx echo.Context, params PostQuestionParams) error
	// 質問を削除
	// (DELETE /api/questions/{question_id})
	DeleteQuestion(ctx echo.Context, questionId QuestionId, params DeleteQuestionParams) error
	// 質問の詳細を取得
	// (GET /api/questions/{question_id})
	GetQuestion(ctx echo.Context, questionId QuestionId) error
	// 質問を更新
	// (PUT /api/questions/{question_id})
	PutQuestion(ctx echo.Context, questionId QuestionId, params PutQuestionParams) error
	// 合宿係を削除
	// (DELETE /api/staffs)
	DeleteStaff(ctx echo.Context, params DeleteStaffParams) error
	// 合宿係の一覧を取得
	// (GET /api/staffs)
	GetStaffs(ctx echo.Context) error
	// 合宿係を追加
	// (POST /api/staffs)
	PostStaff(ctx echo.Context, params PostStaffParams) error
	// ユーザーの回答を取得
	// (GET /api/users/{traq_id}/answers/{question_id})
	GetUserAnswer(ctx echo.Context, traqId TraqId, questionId QuestionId, params GetUserAnswerParams) error
	// 回答を更新
	// (PUT /api/users/{traq_id}/answers/{question_id})
	PutUserAnswer(ctx echo.Context, traqId TraqId, questionId QuestionId, params PutUserAnswerParams) error
	// ユーザーの予算を取得
	// (GET /api/users/{traq_id}/budgets)
	GetUserBudget(ctx echo.Context, traqId TraqId, params GetUserBudgetParams) error
	// ユーザーの予算を設定
	// (POST /api/users/{traq_id}/budgets)
	PostUserBudget(ctx echo.Context, traqId TraqId, params PostUserBudgetParams) error
	// ユーザーの予算を更新
	// (PUT /api/users/{traq_id}/budgets)
	PutUserBudget(ctx echo.Context, traqId TraqId, params PutUserBudgetParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetCamps converts echo context to params.
func (w *ServerInterfaceWrapper) GetCamps(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCamps(ctx)
	// 自身の内部にある Handler の同名関数 GetCamps を実行するだけ
	return err
}

// PostCamp converts echo context to params.
func (w *ServerInterfaceWrapper) PostCamp(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostCampParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostCamp(ctx, params)
	return err
}

// GetDefaultCamp converts echo context to params.
func (w *ServerInterfaceWrapper) GetDefaultCamp(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDefaultCamp(ctx)
	return err
}

// GetCamp converts echo context to params.
func (w *ServerInterfaceWrapper) GetCamp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "camp_id" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "camp_id", ctx.Param("camp_id"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter camp_id: %s", err))
	}
	// やってることは、渡されたパラメータ（ctx）から "camp_id" の値を取り出して変数 campId に格納する
	// パラメータの名前 "camp_id" とパラメータの値 ctx.Param("camp_id") を両方引数に取っているところが解せないけど、多分必要なんでしょう

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCamp(ctx, campId)
	// でもって、最後に自身の Handler 内にある GetCamp を実行。ctx をそのまま扱うんじゃなくて、campId が別個の引数として与えられて嬉しい
	return err
}

// PutCamp converts echo context to params.
func (w *ServerInterfaceWrapper) PutCamp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "camp_id" -------------
	var campId CampId

	err = runtime.BindStyledParameterWithOptions("simple", "camp_id", ctx.Param("camp_id"), &campId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter camp_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutCampParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutCamp(ctx, campId, params)
	return err
}

// PostDirectMessage converts echo context to params.
func (w *ServerInterfaceWrapper) PostDirectMessage(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostDirectMessageParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDirectMessage(ctx, params)
	return err
}

// GetEvents converts echo context to params.
func (w *ServerInterfaceWrapper) GetEvents(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEvents(ctx)
	return err
}

// PostEvent converts echo context to params.
func (w *ServerInterfaceWrapper) PostEvent(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostEventParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEvent(ctx, params)
	return err
}

// GetEvent converts echo context to params.
func (w *ServerInterfaceWrapper) GetEvent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "event_id" -------------
	var eventId EventId

	err = runtime.BindStyledParameterWithOptions("simple", "event_id", ctx.Param("event_id"), &eventId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEvent(ctx, eventId)
	return err
}

// PutEvent converts echo context to params.
func (w *ServerInterfaceWrapper) PutEvent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "event_id" -------------
	var eventId EventId

	err = runtime.BindStyledParameterWithOptions("simple", "event_id", ctx.Param("event_id"), &eventId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutEventParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutEvent(ctx, eventId, params)
	return err
}

// GetParticipants converts echo context to params.
func (w *ServerInterfaceWrapper) GetParticipants(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "event_id" -------------
	var eventId EventId

	err = runtime.BindStyledParameterWithOptions("simple", "event_id", ctx.Param("event_id"), &eventId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetParticipants(ctx, eventId)
	return err
}

// UnregisterEvent converts echo context to params.
func (w *ServerInterfaceWrapper) UnregisterEvent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "event_id" -------------
	var eventId EventId

	err = runtime.BindStyledParameterWithOptions("simple", "event_id", ctx.Param("event_id"), &eventId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UnregisterEventParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnregisterEvent(ctx, eventId, params)
	return err
}

// RegisterEvent converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterEvent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "event_id" -------------
	var eventId EventId

	err = runtime.BindStyledParameterWithOptions("simple", "event_id", ctx.Param("event_id"), &eventId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterEventParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RegisterEvent(ctx, eventId, params)
	return err
}

// GetMe converts echo context to params.
func (w *ServerInterfaceWrapper) GetMe(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMeParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMe(ctx, params)
	return err
}

// GetMyAnswer converts echo context to params.
func (w *ServerInterfaceWrapper) GetMyAnswer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "question_id" -------------
	var questionId QuestionId

	err = runtime.BindStyledParameterWithOptions("simple", "question_id", ctx.Param("question_id"), &questionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter question_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMyAnswerParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMyAnswer(ctx, questionId, params)
	return err
}

// PutAnswer converts echo context to params.
func (w *ServerInterfaceWrapper) PutAnswer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "question_id" -------------
	var questionId QuestionId

	err = runtime.BindStyledParameterWithOptions("simple", "question_id", ctx.Param("question_id"), &questionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter question_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAnswerParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAnswer(ctx, questionId, params)
	return err
}

// GetMyBudget converts echo context to params.
func (w *ServerInterfaceWrapper) GetMyBudget(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMyBudgetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMyBudget(ctx, params)
	return err
}

// PostOption converts echo context to params.
func (w *ServerInterfaceWrapper) PostOption(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostOptionParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostOption(ctx, params)
	return err
}

// PutOption converts echo context to params.
func (w *ServerInterfaceWrapper) PutOption(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "option_id" -------------
	var optionId OptionId

	err = runtime.BindStyledParameterWithOptions("simple", "option_id", ctx.Param("option_id"), &optionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter option_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutOptionParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutOption(ctx, optionId, params)
	return err
}

// GetQuestionGroups converts echo context to params.
func (w *ServerInterfaceWrapper) GetQuestionGroups(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetQuestionGroups(ctx)
	return err
}

// PostQuestionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) PostQuestionGroup(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostQuestionGroupParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostQuestionGroup(ctx, params)
	return err
}

// GetQuestions converts echo context to params.
func (w *ServerInterfaceWrapper) GetQuestions(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetQuestions(ctx)
	return err
}

// PostQuestion converts echo context to params.
func (w *ServerInterfaceWrapper) PostQuestion(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostQuestionParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostQuestion(ctx, params)
	return err
}

// DeleteQuestion converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteQuestion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "question_id" -------------
	var questionId QuestionId

	err = runtime.BindStyledParameterWithOptions("simple", "question_id", ctx.Param("question_id"), &questionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter question_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteQuestionParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteQuestion(ctx, questionId, params)
	return err
}

// GetQuestion converts echo context to params.
func (w *ServerInterfaceWrapper) GetQuestion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "question_id" -------------
	var questionId QuestionId

	err = runtime.BindStyledParameterWithOptions("simple", "question_id", ctx.Param("question_id"), &questionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter question_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetQuestion(ctx, questionId)
	return err
}

// PutQuestion converts echo context to params.
func (w *ServerInterfaceWrapper) PutQuestion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "question_id" -------------
	var questionId QuestionId

	err = runtime.BindStyledParameterWithOptions("simple", "question_id", ctx.Param("question_id"), &questionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter question_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutQuestionParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutQuestion(ctx, questionId, params)
	return err
}

// DeleteStaff converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteStaff(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteStaffParams
	// ------------- Required query parameter "staff_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "staff_id", ctx.QueryParams(), &params.StaffId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter staff_id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteStaff(ctx, params)
	return err
}

// GetStaffs converts echo context to params.
func (w *ServerInterfaceWrapper) GetStaffs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStaffs(ctx)
	return err
}

// PostStaff converts echo context to params.
func (w *ServerInterfaceWrapper) PostStaff(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostStaffParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostStaff(ctx, params)
	return err
}

// GetUserAnswer converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserAnswer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "traq_id" -------------
	var traqId TraqId

	err = runtime.BindStyledParameterWithOptions("simple", "traq_id", ctx.Param("traq_id"), &traqId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter traq_id: %s", err))
	}

	// ------------- Path parameter "question_id" -------------
	var questionId QuestionId

	err = runtime.BindStyledParameterWithOptions("simple", "question_id", ctx.Param("question_id"), &questionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter question_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserAnswerParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserAnswer(ctx, traqId, questionId, params)
	return err
}

// PutUserAnswer converts echo context to params.
func (w *ServerInterfaceWrapper) PutUserAnswer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "traq_id" -------------
	var traqId TraqId

	err = runtime.BindStyledParameterWithOptions("simple", "traq_id", ctx.Param("traq_id"), &traqId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter traq_id: %s", err))
	}

	// ------------- Path parameter "question_id" -------------
	var questionId QuestionId

	err = runtime.BindStyledParameterWithOptions("simple", "question_id", ctx.Param("question_id"), &questionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter question_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutUserAnswerParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutUserAnswer(ctx, traqId, questionId, params)
	return err
}

// GetUserBudget converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserBudget(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "traq_id" -------------
	var traqId TraqId

	err = runtime.BindStyledParameterWithOptions("simple", "traq_id", ctx.Param("traq_id"), &traqId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter traq_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserBudgetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserBudget(ctx, traqId, params)
	return err
}

// PostUserBudget converts echo context to params.
func (w *ServerInterfaceWrapper) PostUserBudget(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "traq_id" -------------
	var traqId TraqId

	err = runtime.BindStyledParameterWithOptions("simple", "traq_id", ctx.Param("traq_id"), &traqId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter traq_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PostUserBudgetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostUserBudget(ctx, traqId, params)
	return err
}

// PutUserBudget converts echo context to params.
func (w *ServerInterfaceWrapper) PutUserBudget(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "traq_id" -------------
	var traqId TraqId

	err = runtime.BindStyledParameterWithOptions("simple", "traq_id", ctx.Param("traq_id"), &traqId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter traq_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutUserBudgetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Forwarded-User" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-User")]; found {
		var XForwardedUser XForwardedUser
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Forwarded-User, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-User", valueList[0], &XForwardedUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Forwarded-User: %s", err))
		}

		params.XForwardedUser = &XForwardedUser
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutUserBudget(ctx, traqId, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// EchoRouter というインターフェース型を定義し、その中に CONNECT とか DELETE とかの関数を宣言している
// その CONNECT とか DELETE とかの関数の定義そのものはリポジトリ内のどこにも書かれていない
// インターフェース型とはあくまで「異なる型」を「単一の型」のように扱うために「持っている属性の条件」を書いたもの

// main.go では、EchoRouter 型の引数をとる RegisterHandlers（↓）の第一引数には e := echo.New() が取られていた
// echo.New() は *Echo 型で、確かに CONNECT とか DELETE とかの関数を持っている
// https://pkg.go.dev/github.com/labstack/echo/v4#Echo.CONNECT

// *Echo 型以外が引数に入ってくるわけないのでこの EchoRouter 型の定義は実用的な意味では不要なのだろうけれど、
// *Echo 型にはそれ以外にもたくさんの関数があるので、その中の HTTP メソッドに関わるこの部分だけ使いますよ、という列挙の意図があるのかも

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {
	// 直上の RegisterHandlers から呼び出されている通り、baseURL は空文字列

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	// 全ての API エンドポイントを登録している
	// 

	router.GET(baseURL+"/api/camps", wrapper.GetCamps)
	router.POST(baseURL+"/api/camps", wrapper.PostCamp)
	router.GET(baseURL+"/api/camps/default", wrapper.GetDefaultCamp)
	router.GET(baseURL+"/api/camps/:camp_id", wrapper.GetCamp)
	router.PUT(baseURL+"/api/camps/:camp_id", wrapper.PutCamp)
	router.POST(baseURL+"/api/dm", wrapper.PostDirectMessage)
	router.GET(baseURL+"/api/events", wrapper.GetEvents)
	router.POST(baseURL+"/api/events", wrapper.PostEvent)
	router.GET(baseURL+"/api/events/:event_id", wrapper.GetEvent)
	router.PUT(baseURL+"/api/events/:event_id", wrapper.PutEvent)
	router.GET(baseURL+"/api/events/:event_id/participants", wrapper.GetParticipants)
	router.DELETE(baseURL+"/api/events/:event_id/register", wrapper.UnregisterEvent)
	router.POST(baseURL+"/api/events/:event_id/register", wrapper.RegisterEvent)
	router.GET(baseURL+"/api/me", wrapper.GetMe)
	router.GET(baseURL+"/api/me/answers/:question_id", wrapper.GetMyAnswer)
	router.PUT(baseURL+"/api/me/answers/:question_id", wrapper.PutAnswer)
	router.GET(baseURL+"/api/me/budgets", wrapper.GetMyBudget)
	router.POST(baseURL+"/api/options", wrapper.PostOption)
	router.PUT(baseURL+"/api/options/:option_id", wrapper.PutOption)
	router.GET(baseURL+"/api/question_groups", wrapper.GetQuestionGroups)
	router.POST(baseURL+"/api/question_groups", wrapper.PostQuestionGroup)
	router.GET(baseURL+"/api/questions", wrapper.GetQuestions)
	router.POST(baseURL+"/api/questions", wrapper.PostQuestion)
	router.DELETE(baseURL+"/api/questions/:question_id", wrapper.DeleteQuestion)
	router.GET(baseURL+"/api/questions/:question_id", wrapper.GetQuestion)
	router.PUT(baseURL+"/api/questions/:question_id", wrapper.PutQuestion)
	router.DELETE(baseURL+"/api/staffs", wrapper.DeleteStaff)
	router.GET(baseURL+"/api/staffs", wrapper.GetStaffs)
	router.POST(baseURL+"/api/staffs", wrapper.PostStaff)
	router.GET(baseURL+"/api/users/:traq_id/answers/:question_id", wrapper.GetUserAnswer)
	router.PUT(baseURL+"/api/users/:traq_id/answers/:question_id", wrapper.PutUserAnswer)
	router.GET(baseURL+"/api/users/:traq_id/budgets", wrapper.GetUserBudget)
	router.POST(baseURL+"/api/users/:traq_id/budgets", wrapper.PostUserBudget)
	router.PUT(baseURL+"/api/users/:traq_id/budgets", wrapper.PutUserBudget)

	// router
}


// この api.gen.go は oapi-codegen というツールによって自動生成されたもの
// 基本的には openapi.yaml から生成されているっぽい
// api.gen.go に含まれているものの一覧 ↓

// 1. enum（列挙型）の定義
//    合宿係からのアンケートについて、各質問の方式を表す QuestionType 型の変数は文字列で、以下の 4 通りの値をもつ
//       "free_number" | "free_text" | "multiple" | "single"
//    TypeScript ではユニオン型によってこれらしか取れない変数を簡単に定義できるが、Go ではユニオン型に相当する書き方が存在しない
//    そこでここに定義されているような方法でそれぞれの値を変数に定義し、いずれかの変数に一致しているかを判定するバリデーション関数を用意する
//    ...はずなのだが、バリデーション関数は見当たらない

// 2. 型定義
//    アプリで実際に使用する型を openapi.yaml から読み取り、全て自動で定義する
//    type CampId = int のような一見不要そうな型も全て実装され、生成されたコードで普通に使われている感じ
//    BadRequest とか NotFound のようなアプリで実際に扱われている型ではないものがなぜ定義されているのはまだわからない

// 3. oneOf（ユニオン型）の対応
//    合宿係からのアンケートに対する解答を表す Answer_Content 型は string | string[] を表現しなくてはならない
//    そこで Answer_Content 型は union という json.RawMessage 型の属性ひとつをもち、
//    それぞれの型 string と string[] の場合で union の中身を json.Unmarshal によりパースして返却する関数が用意されている
//    answers.go には Answer 型に載っている QuestionID から QuestionType を得て読み取り方を決めているっぽい記述がある

// 4. 関数
//    お待ちかね。全て type ServerInterfaceWrapper struct { Handler ServerInterface } という型のメソッドとして定義されている
//    それぞれの関数には ctx という単一の引数が渡される
//        これらの関数の存在意義は、ctx の中から（たとえば ctx.Params() の実行により）引数を取り出して使いやすくした上で、
//        自分自身の内部の Handler に定義されている関数に渡して実行すること
//    自身の Handler には RegisterHandlers で引数として渡される handler.NewServer(db) が入ってくる
//    変数とかが使いやすい状態の関数を handler で手書きして、変換の面倒な部分は api.gen.go の自動生成におまかせ、という感じか

// 5. ハンドラ登録
//    RegisterHandlers が呼び出されたら、引数の router（*Echo 型）に 4 で定義された各関数を装填
//    ここまでしてようやく API が完成、という感じ